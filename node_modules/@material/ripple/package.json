{
  "_args": [
    [
      {
        "raw": "@material/ripple@^0.28.0",
        "scope": "@material",
        "escapedName": "@material%2fripple",
        "name": "@material/ripple",
        "rawSpec": "^0.28.0",
        "spec": ">=0.28.0 <0.29.0",
        "type": "range"
      },
      "/Users/sahiljajodia/Projects/acm-website/android-dot-com/node_modules/material-components-web"
    ]
  ],
  "_from": "@material/ripple@>=0.28.0 <0.29.0",
  "_id": "@material/ripple@0.28.0",
  "_inCache": true,
  "_location": "/@material/ripple",
  "_nodeVersion": "8.1.4",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/ripple-0.28.0.tgz_1515437715752_0.6101372307166457"
  },
  "_npmUser": {
    "name": "acdvorak",
    "email": "acdvorak@gmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "@material/ripple@^0.28.0",
    "scope": "@material",
    "escapedName": "@material%2fripple",
    "name": "@material/ripple",
    "rawSpec": "^0.28.0",
    "spec": ">=0.28.0 <0.29.0",
    "type": "range"
  },
  "_requiredBy": [
    "/@material/button",
    "/@material/checkbox",
    "/@material/dialog",
    "/@material/fab",
    "/@material/icon-toggle",
    "/@material/list",
    "/@material/radio",
    "/@material/select",
    "/@material/selection-control",
    "/@material/tabs",
    "/@material/textfield",
    "/material-components-web"
  ],
  "_resolved": "https://registry.npmjs.org/@material/ripple/-/ripple-0.28.0.tgz",
  "_shasum": "c420011d442ec13c88c45b2d688370a49cd08be4",
  "_shrinkwrap": null,
  "_spec": "@material/ripple@^0.28.0",
  "_where": "/Users/sahiljajodia/Projects/acm-website/android-dot-com/node_modules/material-components-web",
  "bugs": {
    "url": "https://github.com/material-components/material-components-web/issues"
  },
  "dependencies": {
    "@material/base": "^0.24.0",
    "@material/theme": "^0.28.0"
  },
  "description": "The Material Components for the web Ink Ripple effect for web element interactions",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "integrity": "sha512-CBAs4H5QeohIhGLGuAtQvAedkT26kfdmWmAEV9+mKepzOFdO47KmJfuJwUzlCPgYnKq1a1NzYItwJGxJNNG/oA==",
    "shasum": "c420011d442ec13c88c45b2d688370a49cd08be4",
    "tarball": "https://registry.npmjs.org/@material/ripple/-/ripple-0.28.0.tgz"
  },
  "homepage": "https://github.com/material-components/material-components-web#readme",
  "keywords": [
    "material components",
    "material design",
    "ripple"
  ],
  "license": "Apache-2.0",
  "main": "index.js",
  "maintainers": [
    {
      "name": "material-admin",
      "email": "lynnjepsen+npm@google.com"
    },
    {
      "name": "williamernest",
      "email": "williamernest@google.com"
    },
    {
      "name": "moog16",
      "email": "mattgoo@gmail.com"
    },
    {
      "name": "bonniez",
      "email": "bonniez@google.com"
    },
    {
      "name": "patrickrodee",
      "email": "prodee@google.com"
    },
    {
      "name": "aprigogin",
      "email": "andrey.prigogin@gmail.com"
    },
    {
      "name": "kfranqueiro",
      "email": "kenneth.franqueiro@gmail.com"
    },
    {
      "name": "acdvorak",
      "email": "acdvorak@gmail.com"
    },
    {
      "name": "lynnjepsen",
      "email": "lynnjepsen@google.com"
    },
    {
      "name": "bwobrien",
      "email": "obrien.test@gmail.com"
    },
    {
      "name": "amsheehan",
      "email": "alex.m.sheehan@gmail.com"
    }
  ],
  "name": "@material/ripple",
  "optionalDependencies": {},
  "readme": "<!--docs:\ntitle: \"Ripples\"\nlayout: detail\nsection: components\nexcerpt: \"Ink ripple touch feedback effect.\"\niconId: ripple\npath: /catalog/ripples/\n-->\n\n# Ripples\n\nMDC Ripple provides the JavaScript and CSS required to provide components (or any element at all) with a material \"ink ripple\" interaction effect. It is designed to be efficient, uninvasive, and usable without adding any extra DOM to your elements.\n\nMDC Ripple also works without JavaScript, where it gracefully degrades to a simpler CSS-Only implementation.\n\n## Table of Contents\n\n- [An aside regarding browser support](#an-aside-regarding-browser-support)\n- [Installation](#installation)\n- [Usage](#usage)\n  - [Adding Ripple styles](#adding-ripple-styles)\n  - [Adding Ripple JS](#adding-ripple-js)\n  - [Ripple JS API](#ripple-js-api)\n  - [Unbounded Ripples](#unbounded-ripples)\n  - [The mdc-ripple-surface class](#the-mdc-ripple-surface-class)\n  - [Using the foundation](#using-the-foundation)\n  - [Using the vanilla DOM adapter](#using-the-vanilla-dom-adapter)\n- [Tips/Tricks](#tipstricks)\n  - [Integrating ripples into MDC-Web components](#integrating-ripples-into-mdc-web-components)\n  - [Using a sentinel element for a ripple](#using-a-sentinel-element-for-a-ripple)\n  - [Keyboard interaction for custom UI components](#keyboard-interaction-for-custom-ui-components)\n  - [Specifying known element dimensions](#specifying-known-element-dimensions)\n- [Caveat: Edge](#caveat-edge)\n- [Caveat: Safari 9](#caveat-safari)\n- [Caveat: Mobile Safari](#caveat-mobile-safari)\n- [Caveat: Theme Custom Variables](#caveat-theme-custom-variables)\n- [The util API](#the-util-api)\n\n### An aside regarding browser support\n\nIn order to function correctly, MDC Ripple requires a _browser_ implementation of [CSS Variables](https://www.w3.org/TR/css-variables/). MDC Ripple uses custom properties to dynamically position pseudo elements, which allows us to not need any extra DOM for this effect.\n\nBecause we rely on scoped, dynamic CSS variables, static pre-processors such as [postcss-custom-properties](https://github.com/postcss/postcss-custom-properties) will not work as an adequate polyfill ([...yet?](https://github.com/postcss/postcss-custom-properties/issues/32)).\n\nEdge and Safari 9, although they do [support CSS variables](http://caniuse.com/#feat=css-variables), do not support MDC Ripple. See the respective caveats for [Edge](#caveat-edge) and [Safari 9](#caveat-safari) for an explanation.\n\n## Installation\n\n```\nnpm install --save @material/ripple\n```\n\n## Usage\n\n### Adding Ripple styles\n\nGeneral notes:\n\n* Ripple mixins can be applied to a variety of elements representing interactive surfaces. These mixins are also used by other MDC Web components such as Button, FAB, Checkbox, Radio, etc.\n* Surfaces for bounded ripples should have `overflow` set to `hidden`, while surfaces for unbounded ripples should have it set to `visible`\n* When a ripple is successfully initialized on an element using JS, it dynamically adds a `mdc-ripple-upgraded` class to that element. If ripple JS is not initialized but Sass mixins are included on the surface, the ripple will still work, but it uses a simpler, CSS-only implementation which relies on `:hover`, `:focus`, and `:active`.\n\n#### Sass API\n\nIn order to fully style states as well as the ripple effect for pressed state, both `mdc-ripple` mixins below must be included, as well as either the basic or advanced `mdc-states` mixins documented below.\n\nOnce these styles are in place for a component, it is feasible to further override only the parts necessary (e.g. `mdc-states` specifically) for specific variants (e.g. for flat vs. raised buttons).\n\nThese APIs implicitly use pseudo-elements for the ripple effect: `::before` for the background, and `::after` for the foreground.\n\n##### Ripple Mixins\n\nMixin | Description\n--- | ---\n`mdc-ripple-surface` | Adds base styles for a ripple surface\n`mdc-ripple-radius($radius)` | Adds styles for the radius of the ripple effect,<br>for both bounded and unbounded ripples\n\n##### Basic States Mixins\n\nWhen using the basic states mixins, inclusion of the `mdc-states` mixin is mandatory.\nInclusion of `mdc-states-activated` or `mdc-states-selected` is optional, depending on whether activated or selected\nstates are applicable to the component in question.\n\nMixin | Description\n--- | ---\n`mdc-states($color, $has-nested-focusable-element)` | Adds state and ripple styles using the indicated color, deciding opacities based on whether the passed color is light or dark.<br>`$has-nested-focusable-element` defaults to `false` but should be set to `true` if the component contains a focusable element (e.g. an input) under the root node.\n`mdc-states-activated($color, $has-nested-focusable-element)` | Adds state and ripple styles for activated states using the indicated color, deciding opacities based on whether the passed color is light or dark.<br>`$has-nested-focusable-element` defaults to `false` but should be set to `true` if the component contains a focusable element (e.g. an input) under the root node.\n`mdc-states-selected($color, $has-nested-focusable-element)` | Adds state and ripple styles for selected states using the indicated color, deciding opacities based on whether the passed color is light or dark.<br>`$has-nested-focusable-element` defaults to `false` but should be set to `true` if the component contains a focusable element (e.g. an input) under the root node.\n\n##### Advanced States Mixins\n\nWhen using the advanced states mixins, every one of the mixins below should be included at least once to establish base\nstyles for states.\n\nThese mixins can also be used to emit activated or selected styles if applicable, by applying them within a selector for\n`&--activated` or `&--selected` modifier classes.\n\nMixin | Description\n--- | ---\n`mdc-states-base-color($color)` | Sets up base state styles using the provided color\n`mdc-states-hover-opacity($opacity)` | Adds styles for hover state using the provided opacity\n`mdc-states-focus-opacity($opacity, $has-nested-focusable-element)` | Adds styles for focus state using the provided opacity. `$has-nested-focusable-element` defaults to `false` but should be set to `true` if the component contains a focusable element (e.g. an input) under the root node.\n`mdc-states-press-opacity($opacity)` | Adds styles for press state using the provided opacity\n\n### Adding Ripple JS\n\nFirst import the ripple JS.\n\n#### ES2015\n\n```javascript\nimport {MDCRipple, MDCRippleFoundation, util} from '@material/ripple';\n```\n\n##### CommonJS\n\n```javascript\nconst {MDCRipple, MDCRippleFoundation, util} = require('@material/ripple');\n```\n\n#### AMD\n\n```javascript\nrequire('path/to/@material/ripple', function(mdcRipple) {\n  const MDCRipple = mdcRipple.MDCRipple;\n  const MDCRippleFoundation = mdcRipple.MDCRippleFoundation;\n  const util = mdcRipple.util;\n});\n```\n\n#### Global\n\n```javascript\nconst MDCRipple = mdc.ripple.MDCRipple;\nconst MDCRippleFoundation = mdc.ripple.MDCRippleFoundation;\nconst util = mdc.ripple.util;\n```\n\nThen, simply initialize the ripple with the correct DOM element.\n\n```javascript\nconst surface = document.querySelector('.surface');\nconst ripple = new MDCRipple(surface);\n```\n\nYou can also use `attachTo()` as an alias if you don't care about retaining a reference to the\nripple.\n\n```javascript\nMDCRipple.attachTo(document.querySelector('.surface'));\n```\n\n### Ripple JS API\n\nThe component allows for programmatic activation / deactivation of the ripple, for interdependent interaction between\ncomponents. This is used for making form field labels trigger the ripples in their corresponding input elements, for\nexample.\n\n#### MDCRipple.activate()\n\nTriggers an activation of the ripple (the first stage, which happens when the ripple surface is engaged via interaction,\nsuch as a `mousedown` or a `pointerdown` event). It expands from the center.\n\n#### MDCRipple.deactivate()\n\nTriggers a deactivation of the ripple (the second stage, which happens when the ripple surface is engaged via\ninteraction, such as a `mouseup` or a `pointerup` event). It expands from the center.\n\n#### MDCRipple.layout()\n\nRecomputes all dimensions and positions for the ripple element. Useful if a ripple surface's\nposition or dimension is changed programmatically.\n\n### Unbounded Ripples\n\nIf you'd like to use _unbounded_ ripples, such as those used for checkboxes and radio buttons, you\ncan do so either imperatively in JS _or_ declaratively using the DOM.\n\n#### Using JS\n\nYou can set an `unbounded` property to specify whether or not the ripple is unbounded.\n\n```javascript\nconst ripple = new MDCRipple(root);\nripple.unbounded = true;\n```\n\nIf directly using our foundation, you must provide this information directly anyway, so simply have\n`isUnbounded` return `true`.\n\n```javascript\nconst foundation = new MDCRippleFoundation({\n  isUnbounded: () => true,\n  // ...\n});\n```\n\n#### Using DOM (Component Only)\n\nIf you are using our vanilla component for the ripple (not our foundation class), you can add a\ndata attribute to your root element indicating that you wish the ripple to be unbounded:\n\n```html\n<div class=\"surface\" data-mdc-ripple-is-unbounded>\n  <p>A surface</p>\n</div>\n```\n\n### The mdc-ripple-surface class\n\nmdc-ripple contains CSS which exports an `mdc-ripple-surface` class that can turn any element into\na ripple:\n\n```html\n<style>\n.my-surface {\n  width: 200px;\n  height: 200px;\n  background: grey; /* Google Blue 500 :) */\n  border-radius: 2px;\n}\n</style>\n<!-- ... -->\n<div class=\"mdc-ripple-surface my-surface\" tabindex=\"0\">Ripples FTW!</div>\n```\n\nThere are also modifier classes that can be used for styling ripple surfaces using the configured\ntheme's primary and secondary colors\n\n```html\n<div class=\"mdc-ripple-surface mdc-ripple-surface--primary my-surface\" tabindex=\"0\">\n  Surface with a primary-colored ripple.\n</div>\n<div class=\"mdc-ripple-surface mdc-ripple-surface--accent my-surface\" tabindex=\"0\">\n  Surface with a secondary-colored ripple.\n</div>\n```\n\nCheck out our demo (in the top-level `demos/` directory) to see these classes in action.\n\n### Using the foundation\n\nThe MDCRippleFoundation can be used like any other foundation component. Usually, you'll want to use\nit in your component _along_ with the foundation for the actual UI element you're trying to add a\nripple to. The adapter API is as follows:\n\n| Method Signature | Description |\n| --- | --- |\n| `browserSupportsCssVars() => boolean` | Whether or not the given browser supports CSS Variables. When implementing this, please take the [Edge](#caveat-edge) and [Safari 9](#caveat-safari) considerations into account. We provide a `supportsCssVariables` function within the `util.js` which we recommend using, as it handles this for you. |\n| `isUnbounded() => boolean` | Whether or not the ripple should be considered unbounded. |\n| `setUnbounded(unbounded: boolean) => void` | Adds the unbounded class when truthy, removes when falsy |\n| `isSurfaceActive() => boolean` | Whether or not the surface the ripple is acting upon is [active](https://www.w3.org/TR/css3-selectors/#useraction-pseudos). We use this to detect whether or not a keyboard event has activated the surface the ripple is on. This does not need to make use of `:active` (which is what we do); feel free to supply your own heuristics for it. |\n| `isSurfaceDisabled() => boolean` | Whether or not the ripple is attached to a disabled component. If true, the ripple will not activate. |\n| `addClass(className: string) => void` | Adds a class to the ripple surface |\n| `removeClass(className: string) => void` | Removes a class from the ripple surface |\n| `registerInteractionHandler(evtType: string, handler: EventListener) => void` | Registers an event handler that's invoked when the ripple is interacted with using type `evtType`. Essentially equivalent to `HTMLElement.prototype.addEventListener`. |\n| `deregisterInteractionHandler(evtType: string, handler: EventListener) => void` | Unregisters an event handler that's invoked when the ripple is interacted with using type `evtType`. Essentially equivalent to `HTMLElement.prototype.removeEventListener`. |\n| `registerDocumentInteractionHandler(evtType: string, handler: EventListener) => void` | Registers an event handler that's invoked when the documentElement is interacted with using type `evtType` |\n| `deregisterDocumentInteractionHandler(evtType: string, handler: EventListener) => void` | Unregisters an event handler that's invoked when the documentElement is interacted with using type `evtType` |\n| `registerResizeHandler(handler: Function) => void` | Registers a handler to be called when the surface (or its viewport) resizes. Our default implementation adds the handler as a listener to the window's `resize()` event. |\n| `deregisterResizeHandler(handler: Function) => void` | Unregisters a handler to be called when the surface (or its viewport) resizes. Our default implementation removes the handler as a listener to the window's `resize()` event. |\n| `updateCssVariable(varName: string, value: (string or null)) => void` | Programmatically sets the css variable `varName` on the surface to the value specified. |\n| `computeBoundingRect() => ClientRect` | Returns the ClientRect for the surface. |\n| `getWindowPageOffset() => {x: number, y: number}` | Returns the `page{X,Y}Offset` values for the window object as `x` and `y` properties of an object (respectively). |\n\n### Using the vanilla DOM adapter\n\nBecause ripples are used so ubiquitously throughout our codebase, `MDCRipple` has a static\n`createAdapter(instance)` method that can be used to instantiate an adapter object that can be used by\nany `MDCComponent` that needs to instantiate an `MDCRippleFoundation` with custom functionality.\n\n```js\nclass MyMDCComponent extends MDCComponent {\n  constructor() {\n    super(...arguments);\n    this.ripple_ = new MDCRippleFoundation(Object.assign(MDCRipple.createAdapter(this), {\n      isSurfaceActive: () => this.isActive_\n    }));\n    this.ripple_.init();\n  }\n\n  // ...\n}\n```\n\n## Tips/Tricks\n\n### Integrating ripples into MDC-Web components\n\nUsually, you'll want to leverage `::before` and `::after` pseudo-elements when integrating the\nripple into MDC-Web components. Furthermore, when defining your component, you can instantiate the\nripple foundation at the top level, and share logic between those adapters.\n\n### Using a sentinel element for a ripple\n\nIf you find you can't use pseudo-elements to style the ripple, another strategy could be to use a\nsentinel element that goes inside your element and covers its surface. Doing this should get you\nthe same effect.\n\n```html\n<div class=\"my-component\">\n  <div class=\"mdc-ripple-surface\"></div>\n  <!-- your component DOM -->\n</div>\n```\n\n### Keyboard interaction for custom UI components\n\nDifferent keyboard events activate different elements. For example, the space key activate buttons, while the enter key activates links. Handling this by sniffing the key/keyCode of an event is brittle and error-prone, so instead we take the approach of using `adapter.isSurfaceActive()`. The\nway in which our default vanilla DOM adapter determines this is by using\n`element.matches(':active')`. However, this approach will _not_ work for custom components that\nthe browser does not apply this pseudo-class to.\n\nIf you want your component to work properly with keyboard events, you'll have to listen for both `keydown` and `keyup` and set some sort of state that the adapter can use to determine whether or\nnot the surface is \"active\", e.g.\n\n```js\nclass MyComponent {\n  constructor(el) {\n    this.el = el;\n    this.active = false;\n    this.ripple_ = new MDCRippleFoundation({\n      // ...\n      isSurfaceActive: () => this.active\n    });\n    this.el.addEventListener('keydown', evt => {\n      if (isSpace(evt)) {\n        this.active = true;\n      }\n    });\n    this.el.addEventListener('keyup', evt => {\n      if (isSpace(evt)) {\n        this.active = false;\n      }\n    });\n  }\n}\n```\n\n### Specifying known element dimensions\n\nIf you asynchronously load style resources, such as loading stylesheets dynamically via scripts\nor loading fonts, then `adapter.getClientRect()` may by default return _incorrect_ dimensions when\nthe ripple foundation is initialized. For example, if you put a ripple on an element that uses an\nicon font, and the size of the icon font isn't specified at initialization time, then if that icon\nfont hasn't loaded it may report the intrinsic width/height incorrectly. In order to prevent this,\nyou can override the default behavior of `getClientRect()` to return the correct results. For\nexample, if you know an icon font sizes its elements to `24px` width/height, you can do the\nfollowing:\n\n```js\nthis.ripple_ = new MDCRippleFoundation({\n  // ...\n  computeBoundingRect: () => {\n    const {left, top} = element.getBoundingClientRect();\n    const dim = 24;\n    return {\n      left,\n      top,\n      width: dim,\n      height: dim,\n      right: left + dim,\n      bottom: top + dim\n    };\n  }\n});\n```\n\n## Caveat: Edge\n\n> TL;DR ripples are disabled in Edge because of issues with its support of CSS variables in pseudo elements.\n\nEdge introduced CSS variables in version 15. Unfortunately, there are\n[known issues](https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/)\ninvolving its implementation for pseudo-elements which cause ripples to behave incorrectly.\nWe feature-detect Edge's buggy behavior as it pertains to `::before`, and do not initialize ripples if the bug is\nobserved. Earlier versions of Edge (and IE) are not affected, as they do not report support for CSS variables at all,\nand as such ripples are never initialized.\n\n<a name=\"caveat-safari\"></a>\n## Caveat: Safari 9\n\n> TL;DR ripples are disabled in Safari 9 because of a nasty CSS variables bug.\n\nThe ripple works by updating CSS Variables which are used by pseudo-elements. This allows ripple\neffects to work on elements without the need to add a bunch of extra DOM to them. Unfortunately, in\nSafari 9.1, there is a nasty bug where updating a css variable on an element will _not_ trigger a\nstyle recalculation on that element's pseudo-elements which make use of the css variable (try out\n[this codepen](http://codepen.io/traviskaufman/pen/jARYOR) in Chrome, and then in Safari 9.1 to\nsee the issue). We feature-detect around this using alternative heuristics regarding different\nwebkit versions: Webkit builds which have this bug fixed (e.g. the builds used in Safari 10+)\nsupport [CSS 4 Hex Notation](https://drafts.csswg.org/css-color/#hex-notation) while those do not\nhave the fix don't. We use this to reliably feature-detect whether we are working with a WebKit\nbuild that can handle our usage of CSS variables.\n\n## Caveat: Mobile Safari\n\n> TL;DR for CSS-only ripple styles to work as intended, register a `touchstart` event handler on the affected element or its ancestor.\n\nMobile Safari does not trigger `:active` styles noticeably by default, as\n[documented](https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/AdjustingtheTextSize/AdjustingtheTextSize.html#//apple_ref/doc/uid/TP40006510-SW5)\nin the Safari Web Content Guide. This effectively suppresses the intended pressed state styles for CSS-only ripple surfaces. This behavior can be remedied by registering a `touchstart` event handler on the element, or on any common ancestor of the desired elements.\n\nSee [this StackOverflow answer](https://stackoverflow.com/a/33681490) for additional information on mobile Safari's behavior.\n\n## Caveat: Theme Custom Variables\n\n> TL;DR theme custom variable changes will not propagate to ripples if the browser does not support\n> [CSS 4 color-mod functions](https://drafts.csswg.org/css-color/).\n\nThe way that [mdc-theme works](../mdc-theme#mdc-theme-prop-mixin) is that it emits two properties: one with the hard-coded sass variable, and another for a\nCSS variable that can be interpolated. The problem is that ripple backgrounds need to have an opacity, and currently there's no way to opacify a pre-existing color defined by a CSS variable.\nThere is an editor's draft for a `color-mod` function (see link in TL;DR) that _can_ do this:\n\n```css\nbackground: color(var(--mdc-theme-primary) a(6%));\n```\n\nBut as far as we know, no browsers yet support it. We have added a `@supports` clause into our code\nto make sure that it can be used as soon as browsers adopt it, but for now this means that _changes\nto your theme via a custom variable will not propagate to ripples._ We don't see this being a gigantic issue as we envision most users configuring one theme via sass. For places where you do need this, special treatment will have to be given.\n\n### The util API\n\nExternal frameworks and libraries can use the following utility methods when integrating a component.\n\n#### util.supportsCssVariables(windowObj, forceRefresh = false) => Boolean\n\nDetermine whether the current browser supports CSS variables (custom properties). This function caches its result; `forceRefresh` will force recomputation, but is used mainly for testing and should not be necessary in normal use.\n\n#### util.applyPassive(globalObj = window, forceRefresh = false) => object\n\nDetermine whether the current browser supports passive event listeners, and if so, use them. This function caches its result; `forceRefresh` will force recomputation, but is used mainly for testing and should not be necessary in normal use.\n\n#### getMatchesProperty(HTMLElementPrototype) => Function\n\nChoose the correct matches property to use on the current browser.\n\n#### getNormalizedEventCoords(ev, pageOffset, clientRect) => object\n\nDetermines X/Y coordinates of an event normalized for touch events and ripples.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/material-components/material-components-web.git"
  },
  "version": "0.28.0"
}
